/*
 * Copyright (C) 2025 Rick Busarow
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.rickbusarow.matrix

import com.github.gmazzo.buildconfig.BuildConfigExtension
import com.github.gmazzo.buildconfig.BuildConfigSourceSet
import com.github.gmazzo.buildconfig.BuildConfigValue.Expression
import com.github.gmazzo.buildconfig.generators.BuildConfigGenerator
import com.github.gmazzo.buildconfig.generators.BuildConfigGeneratorSpec
import com.github.gmazzo.buildconfig.generators.BuildConfigKotlinGenerator
import com.squareup.kotlinpoet.FileSpec
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.provider.ProviderFactory
import org.gradle.kotlin.dsl.buildConfigField
import javax.inject.Inject

@Suppress("UndocumentedPublicClass", "UndocumentedPublicFunction")
public open class BuildConfigConfigurator @Inject constructor(
  private val buildConfigExtension: BuildConfigExtension,
  @Suppress("unused") private val providerFactory: ProviderFactory
) {

  public fun buildConfig(
    name: String,
    matrixExtension: NamedDomainObjectProvider<MatrixExtension>
  ): NamedDomainObjectProvider<out BuildConfigSourceSet> {

    return buildConfigExtension.sourceSets.named(name) { sourceSet ->

      sourceSet.generator(object : BuildConfigGenerator {
        override fun execute(spec: BuildConfigGeneratorSpec) {

          BuildConfigKotlinGenerator().execute(spec)

          FileSpec.builder(spec.packageName, "MatrixExclusion")
            .addFileComment("This file is generated by the Matrix plugin")
            .build()
            .writeTo(spec.outputDir)
        }
      })

      sourceSet.forClass("com.rickbusarow.matrix", "Boogers") {
        it.expression("what is a top-level expression?")
        it.buildConfigField("snot", "snot is gross")
      }

      sourceSet.forClass("com.rickbusarow.matrix", "Matrix") { clazz ->

        val matrix = matrixExtension.get().matrix()

        val cartesian = matrix.cartesian()
          .joinToString(",\n", "listOf(\n", "\n)") { combination ->
            combination.list.joinToString(", ", "  listOf(", ")") {
              "/* ${it.paramNames.buildConfigName} */ \"${it.value}\""
            }
          }

        clazz.buildConfigField<List<List<String>>>("combinations", Expression(cartesian))

        matrix.paramGroups.forEach { group ->
          clazz.buildConfigField(
            name = group.buildConfigName.getAndFinalize(),
            value = group.paramValues
          )
        }
      }
    }
  }
}
